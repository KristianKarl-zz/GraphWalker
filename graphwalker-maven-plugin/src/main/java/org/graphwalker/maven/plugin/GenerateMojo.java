/*
 * #%L
 * GraphWalker Maven Plugin
 * %%
 * Copyright (C) 2011 - 2013 GraphWalker
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
package org.graphwalker.maven.plugin;

import org.apache.maven.model.Resource;
import org.apache.maven.plugins.annotations.*;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.StringUtils;
import org.graphwalker.core.model.Model;
import org.graphwalker.core.model.ModelElement;
import org.graphwalker.core.model.support.GraphMLModelFactory;
import org.graphwalker.maven.plugin.io.FileInfo;

import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * <p>GenerateMojo class.</p>
 *
 * @author nilols
 */
@Mojo(name = "generate"
        , defaultPhase = LifecyclePhase.GENERATE_SOURCES
        , requiresDependencyResolution = ResolutionScope.TEST)
@Execute(phase = LifecyclePhase.INITIALIZE)
public class GenerateMojo extends AbstractGraphWalkerMojo {

    @Parameter(defaultValue = "${project.resources}", required = true, readonly = true)
    private List<Resource> resources;

    @Parameter(defaultValue = "${project.testResources}", required = true, readonly = true)
    private List<Resource> testResources;

    @Parameter(defaultValue = "${project.build.sourceEncoding}", required = true, readonly = true)
    private String sourceEncoding;

    @Override
    protected List<String> getClasspathElements() {
        List<String> classpathElements = new ArrayList<String>();
        for (Resource resource: testResources) {
            classpathElements.add(resource.getDirectory());
        }
        for (Resource resource: resources) {
            classpathElements.add(resource.getDirectory());
        }
        classpathElements.addAll(super.getClasspathElements());
        return classpathElements;
    }

    @Override
    public void executeMojo() {
        generate(getIncludes(), getExcludes(), resources);
        generate(getIncludes(), getExcludes(), testResources);
    }

    protected List<String> getIncludes() {
        List<String> includes = super.getIncludes();
        if (includes.isEmpty()) {
            includes.add("**/*.graphml"); // TODO: hämta från core alla typer som stödjs
        }
        return includes;
    }

    private void generate(List<String> includes, List<String> excludes, List<Resource> resources) {
        generate(StringUtils.join(includes.toArray(), ","), StringUtils.join(excludes.toArray(), ","), resources);
    }

    private void generate(String includes, String excludes, List<Resource> resources) {
        for (Resource resource: resources) {
            generate(includes, excludes, new File(resource.getDirectory()));
        }
    }

    private void generate(String includes, String excludes, File directory) {
        for (FileInfo fileInfo: findModels(includes, excludes, directory)) {
            generate(fileInfo);
        }
    }

    private void generate(FileInfo fileInfo) {
        String packageName = getPackageName(fileInfo);
        String interfaceName = fileInfo.getBaseName();

        // TODO: ändra så att man inte behöver skapa en specifik factory utan core tar han om att rätt factory används
        GraphMLModelFactory factory = new GraphMLModelFactory();
        Model model = factory.create(fileInfo.getBaseName(), fileInfo.getFilename());
        StringBuilder builder = new StringBuilder();

        builder.append("// This file was generated by GraphWalker").append("\n");
        builder.append("// Any modifications to this file may be lost upon execution of the generate goal.\n");
        builder.append("// Generated on: ").append(getCurrentTime()).append("\n");
        if (!"".equals(packageName)) {
            builder.append("package ").append(packageName).append(";\n\n");
        }
        builder.append("import org.graphwalker.core.annotations.Model;\n\n");
        builder.append("@Model(path=\"").append(fileInfo.getFilename()).append("\", type=\"").append(fileInfo.getExtension()).append("\")\n");
        builder.append("public interface ").append(interfaceName).append("{\n\n");
        Set<String> methodNames = new HashSet<String>();
        for (ModelElement element: model.getModelElements()) {
            methodNames.add(element.getName());
        }
        for (String methodName: methodNames) {
            builder.append("    void ").append(methodName).append("();\n");
        }
        builder.append("}");
        try {
            FileUtils.mkdir(fileInfo.getOutputFile().getParent());
            FileUtils.fileDelete(fileInfo.getOutputFile().getAbsolutePath());
            FileUtils.fileWrite(fileInfo.getOutputFile(), sourceEncoding, builder.toString());
            getLog().info("Generated "+(!"".equals(packageName)?packageName+".":"")+interfaceName);
        } catch (Throwable t) {
            getLog().info("Failed to generate interface for "+fileInfo.getFilename());
            getLog().debug("Failed to generate interface for "+fileInfo.getFilename(), t);
        }
    }

    private String getCurrentTime() {
        Calendar calendar = Calendar.getInstance();
        DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd G 'at' HH:mm:ss z");
        return dateFormat.format(calendar.getTime());
    }

    private List<FileInfo> findModels(String includes, String excludes, File... directories) {
        List<FileInfo> models = new ArrayList<FileInfo>();
        for (File directory: directories) {
            try {
                for (Object filename: FileUtils.getFileNames(directory, includes, excludes, true, true)) {
                    models.add(new FileInfo(directory, (String)filename));
                }
            } catch (Throwable t) {
                getLog().info("Failed to generate interfaces for "+directory.getAbsolutePath());
                getLog().debug("Failed to generate interfaces for "+directory.getAbsolutePath(), t);
            }
        }
        return models;
    }

    private String getPackageName(FileInfo fileInfo) {
        return fileInfo.getPath().replaceAll(File.separator, ".");
    }

}
