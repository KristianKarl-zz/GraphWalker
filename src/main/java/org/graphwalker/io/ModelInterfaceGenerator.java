package org.graphwalker.io;

import org.apache.log4j.Logger;
import org.graphwalker.Keywords;
import org.graphwalker.ModelBasedTesting;
import org.graphwalker.Util;

import java.io.*;
import java.util.Collection;
import java.util.LinkedList;
import java.util.regex.Pattern;

/**
 * Generate interfaces for all models in provided folder
 * Preserve folder structure.
 * <p/>
 * Usage:
 * <pre>
 * java org.graphwalker.io.ModelInterfaceGenerator <model-folder> <java-folder> <package-name> [<model-template-path>]
 * </pre>
 * For example:
 * <pre>
 *
 *     java org.graphwalker.io.ModelInterfaceGenerator src/main/resources/model src/main/java org.graphwalker.ta.model
 *
 * |--src
 * |---main
 * |-----java
 * |-------org
 * |---------graphwalker
 * |-----------ta
 * |-------------model
 * |---------------subfoldera
 * |-----------------ModelA.java      <- autogenerated from ModelA.graphml
 * |-----------------ModelSubA.java   <- autogenerated from ModelA.graphml
 * |---------------subfolderb
 * |-----------------ModelB.java      <- autogenerated from ModelA.graphml
 * |-----resources
 * |-------model
 * |---------subfoldera
 * |-----------ModelA.graphml         <- model for ModelA interface
 * |-----------ModelSubA.graphml      <- model for ModelSubA interface
 * |---------subfolderb
 * |-----------ModelB.graphml         <- model for ModelB interface
 * </pre>
 */
public class ModelInterfaceGenerator {

    private static final String MODEL_EXTENSION = ".graphml";
    private static Logger logger = Util.setupLogger(ModelInterfaceGenerator.class);

    private static final String EXTENSION_SEPARATOR = ".";

    private static final Pattern TRAILING_SPACES =
            Pattern.compile("[ \t]+$", Pattern.MULTILINE);

    private static final String DEFAULT_HEADER =
            "package PACKAGE;\n" +
                    "\n" +
                    "/**\n" +
                    " * Auto-generated interface for model\n" +
                    " */\n" +
                    "public interface INTERFACE_NAME {\n" +
                    "\n";

    private static final String DEFAULT_BODY =
            "\n" +
                    "  /**\n" +
                    "   * This method implements the {EDGE_VERTEX} '{LABEL}'\n" +
                    "   * {DESCRIPTION}\n" +
                    "   */\n" +
                    "  public void {LABEL}() throws Exception;\n";

    private static final String DEFAULT_FOOTER =
            "\n" +
                    "}\n";

    private static final String[] DEFAULT_TEMPLATE =
            {DEFAULT_HEADER, DEFAULT_BODY, DEFAULT_FOOTER};

    private static String javaFolder;
    private static String modelFolder;
    private static String packageName;

    private static File modelTemplateFile;

    /**
     * Generate skeleton from provided .graphml file
     *
     * @param model .graphml file
     * @throws Exception
     */
    protected static void generateAPIFile(File model) throws Exception {
        File javaFile = getJavaFile(model);
        logger.info("Generating interface: " + model.getAbsolutePath() +
                " > " + javaFile.getAbsolutePath());

        ModelBasedTesting mbt = new ModelBasedTesting();
        mbt.readGraph(model.getAbsolutePath());
        if (modelTemplateFile != null) {
            mbt.setTemplate(modelTemplateFile.getAbsolutePath());
        } else {
            mbt.setTemplate(DEFAULT_TEMPLATE);
        }
        mbt.setGenerator(Keywords.GENERATOR_STUB);
        flushModelSkeleton(mbt, javaFile);
    }

    /**
     * Walk through directory and add files with extension .graphml recursively
     *
     * @param path directory path
     * @return all .graphml files in directory and subdirectories
     */
    protected static Collection<File> discoverModels(String path) {
        File directory = new File(path);
        if (!directory.exists() || !directory.isDirectory()) {
            throw new RuntimeException(path + " is not directory with models");
        }

        Collection<File> collection = new LinkedList<File>();
        addFilesRecursively(collection, directory);
        return collection;
    }


    protected static void addFilesRecursively(Collection<File> collection, File directory) {
        File[] files = directory.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            if (file.isDirectory()) {
                addFilesRecursively(collection, file);
            } else if (file.isFile() && file.getName().endsWith(MODEL_EXTENSION)) {
                collection.add(file);
            }
        }
    }

    /**
     * Process model and save to file using model template
     *
     * @param mbt    MBT reference with parsed model
     * @param output output file
     * @throws Exception
     */
    protected static void flushModelSkeleton(ModelBasedTesting mbt, File output) throws Exception {

        File parentFile = output.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream stream = new PrintStream(baos);

        mbt.writePath(stream);

        String content = baos.toString();
        content = content.replace("INTERFACE_NAME", getBaseName(output.getName()));
        content = content.replace("PACKAGE", getRelativePath(output, javaFolder).replace('/', '.'));
        content = TRAILING_SPACES.matcher(content).replaceAll("");
        writeStringToFile(output, content);
    }

    /**
     * @param name file name
     * @return file name without extension
     */
    protected static String getBaseName(String name) {
        int idx = name.lastIndexOf(EXTENSION_SEPARATOR);
        return idx > 0 ? name.substring(0, idx) : name;
    }

    /**
     * Flush string to file
     *
     * @param output  output file
     * @param content string
     * @throws FileNotFoundException
     */
    protected static void writeStringToFile(File output, String content) throws FileNotFoundException {
        PrintWriter out = new PrintWriter(output);
        out.print(content);
        out.close();
    }

    protected static String getRelativePath(File model, String part) {
        String absolutePath = model.getParentFile().getAbsolutePath();
        return absolutePath.substring(absolutePath.lastIndexOf(part) + part.length() + 1);
    }

    protected static File getJavaFile(File model) {
        return new File(javaFolder, packageName.replace('.', '/') + "/"
                + getRelativePath(model, modelFolder) + "/"
                + getBaseName(model.getName()) + ".java");
    }

    public static void main(String[] args) throws Exception {

        if (args.length < 3 || args.length > 4) {
            throw new IllegalArgumentException("Usage: java org.graphwalker.ModelInterfaceGenerator " +
                    "<model-folder> <java-folder> <package-name> [<model-template-path>]");
        }

        modelFolder = args[0];
        javaFolder = args[1];
        packageName = args[2];

        if (args.length > 3) {
            modelTemplateFile = new File(args[3]);
            if (!modelTemplateFile.exists() || modelTemplateFile.length() == 0) {
                throw new IllegalArgumentException("Model template does not exist");
            }
        }

        Collection<File> models = discoverModels(modelFolder);

        for (File model : models) {
            generateAPIFile(model);
        }
    }

}
